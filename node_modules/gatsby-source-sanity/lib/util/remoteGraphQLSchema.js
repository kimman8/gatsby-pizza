"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypeMapFromGraphQLSchema = exports.getRemoteGraphQLSchema = exports.defaultTypeMap = void 0;
const lodash_1 = require("lodash");
const graphql_1 = require("gatsby/graphql");
const normalize_1 = require("./normalize");
exports.defaultTypeMap = {
    scalars: [],
    objects: {},
    unions: {},
};
async function getRemoteGraphQLSchema(client, config) {
    const { graphqlTag } = config;
    const { dataset } = client.config();
    try {
        const api = await client.request({
            url: `/apis/graphql/${dataset}/${graphqlTag}`,
            headers: { Accept: 'application/graphql' },
        });
        return api;
    }
    catch (err) {
        const code = lodash_1.get(err, 'response.statusCode');
        const message = lodash_1.get(err, 'response.body.message', lodash_1.get(err, 'response.statusMessage') || err.message);
        const is404 = code === 404 || /schema not found/i.test(message);
        throw new Error(is404
            ? `GraphQL API not deployed - see https://github.com/sanity-io/gatsby-source-sanity#graphql-api for more info\n\n`
            : `${message}`);
    }
}
exports.getRemoteGraphQLSchema = getRemoteGraphQLSchema;
function getTypeMapFromGraphQLSchema(sdl) {
    const typeMap = { objects: {}, scalars: [], unions: {} };
    const remoteSchema = graphql_1.parse(sdl);
    const groups = Object.assign({ ObjectTypeDefinition: [], ScalarTypeDefinition: [], UnionTypeDefinition: [] }, lodash_1.groupBy(remoteSchema.definitions, 'kind'));
    typeMap.scalars = graphql_1.specifiedScalarTypes
        .map((scalar) => scalar.name)
        .concat(groups.ScalarTypeDefinition.map((typeDef) => typeDef.name.value));
    const objects = {};
    typeMap.objects = groups.ObjectTypeDefinition.reduce((acc, typeDef) => {
        if (typeDef.name.value === 'RootQuery') {
            return acc;
        }
        const name = normalize_1.getTypeName(typeDef.name.value);
        acc[name] = {
            name,
            kind: 'Object',
            isDocument: Boolean((typeDef.interfaces || []).find((iface) => iface.name.value === 'Document')),
            fields: (typeDef.fields || []).reduce((fields, fieldDef) => {
                if (isAlias(fieldDef)) {
                    const aliasFor = getAliasDirective(fieldDef) || '';
                    fields[aliasFor] = {
                        type: fieldDef.type,
                        namedType: { kind: 'NamedType', name: { kind: 'Name', value: 'JSON' } },
                        isList: false,
                        aliasFor: null,
                        isReference: false,
                    };
                    const aliasName = '_' + lodash_1.camelCase(`raw ${aliasFor}`);
                    fields[aliasName] = {
                        type: { kind: 'NamedType', name: { kind: 'Name', value: 'JSON' } },
                        namedType: { kind: 'NamedType', name: { kind: 'Name', value: 'JSON' } },
                        aliasFor,
                        isList: false,
                        isReference: false,
                    };
                    return fields;
                }
                const namedType = unwrapType(fieldDef.type);
                fields[fieldDef.name.value] = {
                    type: fieldDef.type,
                    namedType,
                    isList: isListType(fieldDef.type),
                    aliasFor: null,
                    isReference: Boolean(getReferenceDirective(fieldDef)),
                };
                // Add raw alias if not scalar
                if (!typeMap.scalars.includes(namedType.name.value)) {
                    const aliasName = '_' + lodash_1.camelCase(`raw ${fieldDef.name.value}`);
                    fields[aliasName] = {
                        type: { kind: 'NamedType', name: { kind: 'Name', value: 'JSON' } },
                        namedType: { kind: 'NamedType', name: { kind: 'Name', value: 'JSON' } },
                        aliasFor: fieldDef.name.value,
                        isList: false,
                        isReference: false,
                    };
                }
                return fields;
            }, {}),
        };
        return acc;
    }, objects);
    const unions = {};
    typeMap.unions = groups.UnionTypeDefinition.reduce((acc, typeDef) => {
        const name = normalize_1.getTypeName(typeDef.name.value);
        acc[name] = {
            name,
            types: (typeDef.types || []).map((type) => normalize_1.getTypeName(type.name.value)),
        };
        return acc;
    }, unions);
    return typeMap;
}
exports.getTypeMapFromGraphQLSchema = getTypeMapFromGraphQLSchema;
function isAlias(field) {
    return getAliasDirective(field) !== null;
}
function unwrapType(typeNode) {
    if (['NonNullType', 'ListType'].includes(typeNode.kind)) {
        const wrappedType = typeNode;
        return unwrapType(wrappedType.type);
    }
    return typeNode;
}
function isListType(typeNode) {
    if (typeNode.kind === 'ListType') {
        return true;
    }
    if (typeNode.kind === 'NonNullType') {
        const node = typeNode;
        return isListType(node.type);
    }
    return false;
}
function getAliasDirective(field) {
    const alias = (field.directives || []).find((dir) => dir.name.value === 'jsonAlias');
    if (!alias) {
        return null;
    }
    const forArg = (alias.arguments || []).find((arg) => arg.name.value === 'for');
    if (!forArg) {
        return null;
    }
    return graphql_1.valueFromAST(forArg.value, graphql_1.GraphQLString, {});
}
function getReferenceDirective(field) {
    return (field.directives || []).find((dir) => dir.name.value === 'reference');
}
//# sourceMappingURL=remoteGraphQLSchema.js.map
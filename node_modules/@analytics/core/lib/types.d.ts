declare module "analytics" {
  /**
   * Core Analytic constants. These are exposed for third party plugins & listeners
   * @typedef {Object} constants
   * @property {ANON_ID} ANON_ID - Anonymous visitor Id localstorage key
   * @property {USER_ID} USER_ID - Visitor Id localstorage key
   * @property {USER_TRAITS} USER_TRAITS - Visitor traits localstorage key
   */
  type constants = {
      ANON_ID: ANON_ID;
      USER_ID: USER_ID;
      USER_TRAITS: USER_TRAITS;
  };

  /**
   * Anonymous visitor Id localstorage key
   * @typedef {String} ANON_ID
   */
  type ANON_ID = string;

  /**
   * Visitor Id localstorage key
   * @typedef {String} USER_ID
   */
  type USER_ID = string;

  /**
   * Visitor traits localstorage key
   * @typedef {String} USER_TRAITS
   */
  type USER_TRAITS = string;

  /**
   * Analytics library configuration
   *
   * After the library is initialized with config, the core API is exposed & ready for use in the application.
   *
   * @param {object} config - analytics core config
   * @param {string} [config.app] - Name of site / app
   * @param {string} [config.version] - Version of your app
   * @param {boolean} [config.debug] - Should analytics run in debug mode
   * @param {Array.<Object>}  [config.plugins] - Array of analytics plugins
   * @return {AnalyticsInstance} Analytics Instance
   * @example
   *
   * import Analytics from 'analytics'
   * import pluginABC from 'analytics-plugin-abc'
   * import pluginXYZ from 'analytics-plugin-xyz'
   *
   * // initialize analytics
   * const analytics = Analytics({
   *   app: 'my-awesome-app',
   *   plugins: [
   *     pluginABC,
   *     pluginXYZ
   *   ]
   * })
   *
   */
  function analytics(config: {
      app?: string;
      version?: string;
      debug?: boolean;
      plugins?: Array<AnalyticsPlugin>;
  }): AnalyticsInstance;

  /**
   * Management methods for plugins. This is also where [custom methods](https://bit.ly/329vFXy) are loaded into the instance.
   * @typedef {Object} Plugins
   * @property {EnablePlugin} enable - Set storage value
   * @property {DisablePlugin} disable - Remove storage value
   * @example
   *
   * // Enable a plugin by namespace
   * analytics.plugins.enable('keenio')
   *
   * // Disable a plugin by namespace
   * analytics.plugins.disable('google-analytics')
   */
  type Plugins = {
      enable: EnablePlugin;
      disable: DisablePlugin;
  };

  /**
   * Enable analytics plugin
   * @typedef {Function} EnablePlugin
   * @param  {String|Array} plugins - name of plugins(s) to disable
   * @param  {Function} [callback] - callback after enable runs
   * @example
   *
   * analytics.plugins.enable('google')
   *
   * // Enable multiple plugins at once
   * analytics.plugins.enable(['google', 'segment'])
   */
  type EnablePlugin = (plugins: string | any[], callback?: (...params: any[]) => any) => void;

  /**
   * Disable analytics plugin
   * @typedef {Function} DisablePlugin
   * @param  {String|Array} name - name of integration(s) to disable
   * @param  {Function} callback - callback after disable runs
   * @example
   *
   * analytics.plugins.disable('google')
   *
   * analytics.plugins.disable(['google', 'segment'])
   */
  type DisablePlugin = (name: string | any[], callback: (...params: any[]) => any) => void;

  /**
   * Analytic instance returned from initialization
   * @typedef {Object} AnalyticsInstance
   * @property {Identify} identify - Identify a user
   * @property {Track} track - Track an analytics event
   * @property {Page} page - Trigger page view
   * @property {User} user - Get user data
   * @property {Reset} reset - Clear information about user & reset analytics
   * @property {Ready} ready - Fire callback on analytics ready event
   * @property {On} on - Fire callback on analytics lifecycle events.
   * @property {Once} once - Fire callback on analytics lifecycle events once.
   * @property {GetState} getState - Get data about user, activity, or context.
   * @property {Storage} storage - storage methods
   * @property {Plugins} plugins - plugin methods
   */
  export type AnalyticsInstance = {
      identify: Identify;
      track: Track;
      page: Page;
      user: User;
      reset: Reset;
      ready: Ready;
      on: On;
      once: Once;
      getState: GetState;
      storage: Storage;
      plugins: Plugins;
  };

  /**
   * Identify a user. This will trigger `identify` calls in any installed plugins and will set user data in localStorage
   * @typedef {Function} Identify
   * @param  {String}   userId  - Unique ID of user
   * @param  {Object}   [traits]  - Object of user traits
   * @param  {Object}   [options] - Options to pass to identify call
   * @param  {Function} [callback] - Callback function after identify completes
   * @returns {Promise<void>}
   * @api public
   *
   * @example
   *
   * // Basic user id identify
   * analytics.identify('xyz-123')
   *
   * // Identify with additional traits
   * analytics.identify('xyz-123', {
   *   name: 'steve',
   *   company: 'hello-clicky'
   * })
   *
   * // Fire callback with 2nd or 3rd argument
   * analytics.identify('xyz-123', () => {
   *   console.log('do this after identify')
   * })
   *
   * // Disable sending user data to specific analytic tools
   * analytics.identify('xyz-123', {}, {
   *   plugins: {
   *     // disable sending this identify call to segment
   *     segment: false
   *   }
   * })
   *
   * // Send user data to only to specific analytic tools
   * analytics.identify('xyz-123', {}, {
   *   plugins: {
   *     // disable this specific identify in all plugins except customerio
   *     all: false,
   *     customerio: true
   *   }
   * })
   */
  type Identify = (userId: string, traits?: any, options?: any, callback?: (...params: any[]) => any) => Promise<any>;

  /**
   * Track an analytics event. This will trigger `track` calls in any installed plugins
   * @typedef {Function} Track
   * @param  {String}   eventName - Event name
   * @param  {Object}   [payload]   - Event payload
   * @param  {Object}   [options]   - Event options
   * @param  {Function} [callback]  - Callback to fire after tracking completes
   * @returns {Promise<void>}
   * @api public
   *
   * @example
   *
   * // Basic event tracking
   * analytics.track('buttonClicked')
   *
   * // Event tracking with payload
   * analytics.track('itemPurchased', {
   *   price: 11,
   *   sku: '1234'
   * })
   *
   * // Fire callback with 2nd or 3rd argument
   * analytics.track('newsletterSubscribed', () => {
   *   console.log('do this after track')
   * })
   *
   * // Disable sending this event to specific analytic tools
   * analytics.track('cartAbandoned', {
   *   items: ['xyz', 'abc']
   * }, {
   *   plugins: {
   *     // disable track event for segment
   *     segment: false
   *   }
   * })
   *
   * // Send event to only to specific analytic tools
   * analytics.track('customerIoOnlyEventExample', {
   *   price: 11,
   *   sku: '1234'
   * }, {
   *   plugins: {
   *     // disable this specific track call all plugins except customerio
   *     all: false,
   *     customerio: true
   *   }
   * })
   */
  type Track = (eventName: string, payload?: any, options?: any, callback?: (...params: any[]) => any) => Promise<any>;

  /**
   * Trigger page view. This will trigger `page` calls in any installed plugins
   * @typedef {Function} Page
   * @param  {PageData} [data] - Page data overrides.
   * @param  {Object}   [options] - Page tracking options
   * @param  {Function} [callback] - Callback to fire after page view call completes
   * @returns {Promise<void>}
   * @api public
   *
   * @example
   *
   * // Basic page tracking
   * analytics.page()
   *
   * // Page tracking with page data overrides
   * analytics.page({
   *   url: 'https://google.com'
   * })
   *
   * // Fire callback with 1st, 2nd or 3rd argument
   * analytics.page(() => {
   *   console.log('do this after page')
   * })
   *
   * // Disable sending this pageview to specific analytic tools
   * analytics.page({}, {
   *   plugins: {
   *     // disable page tracking event for segment
   *     segment: false
   *   }
   * })
   *
   * // Send pageview to only to specific analytic tools
   * analytics.page({}, {
   *   plugins: {
   *     // disable this specific page in all plugins except customerio
   *     all: false,
   *     customerio: true
   *   }
   * })
   */
  type Page = (data?: PageData, options?: any, callback?: (...params: any[]) => any) => Promise<any>;

  /**
   * Get user data
   * @typedef {Function} User
   * @param {string} [key] - dot.prop.path of user data. Example: 'traits.company.name'
   * @returns {string|object} value of user data or null
   *
   * @example
   *
   * // Get all user data
   * const userData = analytics.user()
   *
   * // Get user id
   * const userId = analytics.user('userId')
   *
   * // Get user company name
   * const companyName = analytics.user('traits.company.name')
   */
  type User = (key?: string) => string | any;

  /**
   * Clear all information about the visitor & reset analytic state.
   * @typedef {Function} Reset
   * @param {Function} [callback] - Handler to run after reset
   * @returns {Promise<void>}
   * @example
   *
   * // Reset current visitor
   * analytics.reset()
   */
  type Reset = (callback?: (...params: any[]) => any) => Promise<any>;

  /**
   * Fire callback on analytics ready event
   * @typedef {Function} Ready
   * @param  {Function} callback - function to trigger when all providers have loaded
   * @returns {DetachListeners} - Function to detach listener
   *
   * @example
   *
   * analytics.ready() => {
   *   console.log('all plugins have loaded or were skipped', payload)
   * })
   */
  type Ready = (callback: (...params: any[]) => any) => DetachListeners;

  /**
   * Attach an event handler function for analytics lifecycle events.
   * @typedef {Function} On
   * @param  {String}   name - Name of event to listen to
   * @param  {Function} callback - function to fire on event
   * @return {DetachListeners} - Function to detach listener
   *
   * @example
   *
   * // Fire function when 'track' calls happen
   * analytics.on('track', ({ payload }) => {
   *   console.log('track call just happened. Do stuff')
   * })
   *
   * // Remove listener before it is called
   * const removeListener = analytics.on('track', ({ payload }) => {
   *   console.log('This will never get called')
   * })
   *
   * // cleanup .on listener
   * removeListener()
   */
  type On = (name: string, callback: (...params: any[]) => any) => DetachListeners;

  /**
   * Detach listeners
   * @typedef {Function} DetachListeners
   */
  type DetachListeners = () => void;

  /**
   * Attach a handler function to an event and only trigger it only once.
   * @typedef {Function} Once
   * @param  {String} name - Name of event to listen to
   * @param  {Function} callback - function to fire on event
   * @return {DetachListeners} - Function to detach listener
   *
   * @example
   *
   * // Fire function only once 'track'
   * analytics.once('track', ({ payload }) => {
   *   console.log('This will only triggered once when analytics.track() fires')
   * })
   *
   * // Remove listener before it is called
   * const listener = analytics.once('track', ({ payload }) => {
   *   console.log('This will never get called b/c listener() is called')
   * })
   *
   * // cleanup .once listener before it fires
   * listener()
   */
  type Once = (name: string, callback: (...params: any[]) => any) => DetachListeners;

  /**
   * Get data about user, activity, or context. Access sub-keys of state with `dot.prop` syntax.
   * @typedef {Function} GetState
   * @param  {string} [key] - dot.prop.path value of state
   * @return {any}
   *
   * @example
   *
   * // Get the current state of analytics
   * analytics.getState()
   *
   * // Get a subpath of state
   * analytics.getState('context.offline')
   */
  type GetState = (key?: string) => any;

  /**
   * Storage utilities for persisting data.
   * These methods will allow you to save data in localStorage, cookies, or to the window.
   * @typedef {Object} Storage
   * @property {GetItem} getItem - Get value from storage
   * @property {SetItem} setItem - Set storage value
   * @property {RemoveItem} removeItem - Remove storage value
   *
   * @example
   *
   * // Pull storage off analytics instance
   * const { storage } = analytics
   *
   * // Get value
   * storage.getItem('storage_key')
   *
   * // Set value
   * storage.setItem('storage_key', 'value')
   *
   * // Remove value
   * storage.removeItem('storage_key')
   */
  type Storage = {
      getItem: GetItem;
      setItem: SetItem;
      removeItem: RemoveItem;
  };

  /**
   * Get value from storage
   * @typedef {Function} GetItem
   * @param {String} key - storage key
   * @param {Object} [options] - storage options
   * @return {Any}
   *
   * @example
   *
   * analytics.storage.getItem('storage_key')
   */
  type GetItem = (key: string, options?: any) => any;

  /**
   * Set storage value
   * @typedef {Function} SetItem
   * @param {String} key - storage key
   * @param {any} value - storage value
   * @param {Object} [options] - storage options
   *
   * @example
   *
   * analytics.storage.setItem('storage_key', 'value')
   */
  type SetItem = (key: string, value: any, options?: any) => void;

  /**
   * Remove storage value
   * @typedef {Function} RemoveItem
   * @param {String} key - storage key
   * @param {Object} [options] - storage options
   *
   * @example
   *
   * analytics.storage.removeItem('storage_key')
   */
  type RemoveItem = (key: string, options?: any) => void;

  /**
   * Async reduce over matched plugin methods
   * Fires plugin functions
   */
  function processEvent(): void;

  /**
   * Return array of event names
   * @param  {String} eventType - original event type
   * @param  {String} namespace - optional namespace postfix
   * @return {array} - type, method, end
   */
  function getEventNames(eventType: string, namespace: string): any[];

  /**
   * Generate arguments to pass to plugin methods
   * @param  {Object} instance - analytics instance
   * @param  {array} abortablePlugins - plugins that can be cancelled by caller
   * @return {*} function to inject plugin params
   */
  function argumentFactory(instance: any, abortablePlugins: any[]): any;

  /**
   * Verify plugin is not calling itself with whatever:myPluginName self refs
   */
  function validateMethod(): void;

  /**
   * Return the canonical URL and rmove the hash.
   * @param  {string} search - search param
   * @return {string} return current canonical URL
   */
  function currentUrl(search: string): string;

  /**
   * Page data for overides
   * @typedef {object} PageData
   * @property {string} [title] - Page title
   * @property {string} [url] - Page url
   * @property {string} [path] - Page path
   * @property {string} [search] - Page search
   * @property {string} [width] - Page width
   * @property {string} [height] - Page height
   */
  type PageData = {
      title?: string;
      url?: string;
      path?: string;
      search?: string;
      width?: string;
      height?: string;
  };

  /**
   * Get information about current page
   * @typedef {Function} getPageData
   * @param  {PageData} [pageData = {}] - Page data overides
   * @return {PageData} resolved page data
   */
  type getPageData = (pageData?: PageData) => PageData;

  /**
   * @typedef {Object} AnalyticsPlugin
   * @property {string} name - Name of plugin
   * @property {Object} [EVENTS] - exposed events of plugin
   * @property {Object} [config] - Configuration of plugin
   * @property {function} [initialize] - Load analytics scripts method
   * @property {function} [page] - Page visit tracking method
   * @property {function} [track] - Custom event tracking method
   * @property {function} [identify] - User identify method
   * @property {function} [loaded] - Function to determine if analytics script loaded
   * @property {function} [ready] - Fire function when plugin ready
   */
  type AnalyticsPlugin = {
      name: string;
      EVENTS?: any;
      config?: any;
      initialize?: (...params: any[]) => any;
      page?: (...params: any[]) => any;
      track?: (...params: any[]) => any;
      identify?: (...params: any[]) => any;
      loaded?: (...params: any[]) => any;
      ready?: (...params: any[]) => any;
  };


  export const CONSTANTS: constants;

  export const init: typeof analytics;

  export const Analytics: typeof analytics;

  export default analytics;
}